---
title: "Valuation Summary"
author: "Cook County Assessor's Office"
date: "`r format(Sys.time(), '%d %B, %Y @ %r')`"
output: html_document
params:
  filter: "TRUE"
  triad: "City"
---

```{r setup, include=FALSE}
# Load R libraries
library(arrow)
library(assessr)
library(ccao)
library(dplyr)
library(DT)
library(forcats)
library(ggplot2)
library(glue)
library(here)
library(lubridate)
library(purrr)
library(scales)
library(sf)
library(stringr)
library(tidyr)

# Hide code output and make plots take 100% of page width
knitr::opts_chunk$set(echo = FALSE, out.width = '100%')

# Filter to specific triad. Set with system variable else param defined in yaml
report_filter <- Sys.getenv("R_REPORT_FILTER", unset = NA)
report_filter <- as.logical(ifelse(
  !is.na(report_filter),
  report_filter,
  params$filter
))

# Triad to use for report if filtered. Set with system variable else param
# defined in yaml
report_triad <- Sys.getenv("R_REPORT_TRIAD", unset = NA)
report_triad <- ifelse(!is.na(report_triad), report_triad, params$triad)
```

```{r val_summary, message=FALSE}
# Load final assessment values from file (created by valuation.R). These include
# post-modeling adjustments
pv_final_values <- read_parquet(
    here("output", "data", "finalvalues.parquet")
  ) %>%
  filter(meta_modeling_group != "BB") %>%
  mutate(
    pri_yr_board_est = meta_pri_yr_board_est_bldg + meta_pri_yr_board_est_land,
    mailed_est = meta_mailed_est_bldg + meta_mailed_est_land,
    certified_est = meta_certified_est_bldg + meta_certified_est_land,
    town_name = town_convert(meta_town_code),
    triad = factor(
      town_get_triad(meta_town_code, name = TRUE),
      levels = c("North", "City", "South")
    ),
    ratio_capped = !between(lgbm_value / meta_sale_price, 0.7, 2.0),
    board_yoy_pct_change = (final_value - pri_yr_board_est) / pri_yr_board_est,
    certified_yoy_pct_change = (final_value - certified_est) / certified_est,
    meta_modeling_group = fct_recode(
      factor(meta_modeling_group, levels = c("SF", "MF")),
      "Single-Family" = "SF",
      "Multi-Family" = "MF"
    )
  )

# Save report year and assessment date
report_year <- max(pv_final_values$meta_year)
assessment_year <- lubridate::year(max(pv_final_values$meta_sale_date))

# Filter to specific triad based on report parameters
if (report_filter) {
pv_final_values <- pv_final_values %>%
  filter(triad == report_triad)
}

# Summarize the full modeling pipeline results by township
pv_summary <- pv_final_values %>%
  
  # Need to exclude multi code PINs from the summary, as their prior year
  # values may be for all property on the PIN, rather than a single building
  filter(!ind_multi_pin) %>%
  group_by(town_name) %>%
  summarize(
    triad = first(triad),
    num_props = n(),
    num_ratios_capped = sum(ratio_capped, na.rm = TRUE),
    median_board_est = median(pri_yr_board_est, na.rm = TRUE),
    median_certified_est = median(certified_est, na.rm = TRUE),
    median_sale_price = median(meta_sale_price, na.rm = TRUE),
    median_model_value = median(lgbm_value, na.rm = TRUE),
    median_final_value = median(final_value, na.rm = TRUE),
    median_ratio = median(final_value / meta_sale_price, na.rm = TRUE),
    med_yoy_pct_change_board = median(board_yoy_pct_change, na.rm = T),
    med_yoy_pct_change_cert = median(certified_yoy_pct_change, na.rm = T)
  )

# Create a container with custom column headers for summary table
headers <- htmltools::withTags(table(
  class = "display", 
  thead(
    tr(
      th(rowspan = 2, "Township"),
      th(rowspan = 2, "Triad"),
      th(rowspan = 2, "Num. PINs"),
      th(rowspan = 2, "Num. Ratios Capped"),
      th(colspan = 8, "Median Values"),
    ),
    tr(
      th(glue("BoR Value ({report_year - 1})")),
      th(glue("Certified Value ({report_year})")),
      th(glue("Sale Price ({report_year})")),
      th("Initial Model Value"),
      th("Final Model Value"),
      th("Final Model Ratio"),
      th("Median Percent Change (BoR to Final)"),
      th("Median Percent Change (Cert to Final)")
    )
  )
))

# Create an interactive table of the valuation summary results by township
pv_summary %>%
  datatable(
    rownames = FALSE,
    filter = "none",
    selection = "none",
    container = headers,
    escape = FALSE,
    options = list(
      autoWidth = TRUE,
      paging = FALSE,
      searching = FALSE,
      info = FALSE
    )
  ) %>%
  formatRound(3:4, digits = 0) %>%
  formatRound(10, digits = 2) %>%
  formatCurrency(c(5:9), digits = 0) %>%
  formatPercentage(c(11, 12), digits = 1)
```

<br>

## Map of Median Percent Change by Township

```{r val_map, warning=FALSE, message=FALSE}
# Generate township-level map of YoY percent change for all finalized values
pv_summary %>%
  left_join(ccao::town_shp, by = c("town_name" = "township_name")) %>%
  st_set_geometry("geometry") %>%
  pivot_longer(
    cols = c(med_yoy_pct_change_board, med_yoy_pct_change_cert),
    names_to = "type",
    values_to = "change"
  ) %>%
  mutate(
    type = fct_recode(
      factor(type, levels = c(
        "med_yoy_pct_change_board", 
        "med_yoy_pct_change_cert"
      )),
      "BoR to Final Model Value" = "med_yoy_pct_change_board",
      "Certified to Final Model Value" = "med_yoy_pct_change_cert"
    )
  ) %>%
ggplot() +
  geom_sf(aes(fill = change, geometry = geometry)) +
  scale_fill_distiller(
    name = "Median\n% Change",
    palette = "BuPu",
    labels = scales::percent,
    direction = 1
  ) +
  facet_wrap(vars(type)) +
  theme_void() +
  theme(
    strip.text.x = element_text(size = 12),
    legend.title = element_text(margin = margin(b = 6))
  )
```

## Overall Value Distribution

```{r value_dist, warning=FALSE, message=FALSE}
# Plot density of previous, predicted, adjusted value and sale price to look
# for discrepancies in distributions
pv_final_values %>%
  pivot_longer(c(
    pri_yr_board_est, certified_est, meta_sale_price,
    lgbm_value, final_value
  )) %>%
  mutate(name = fct_recode(
    factor(name, levels = c(
      "pri_yr_board_est", "certified_est",
      "meta_sale_price", "lgbm_value", "final_value"
    )),
    "BoR Value (2 Years Ago)" = "pri_yr_board_est",
    "Certified Value (Prior Year)" = "certified_est",
    "Sale Price (Prior Year)" = "meta_sale_price",
    "Initial Model Value" = "lgbm_value",
    "Final Model Value" = "final_value",
  )) %>%
ggplot() +
  geom_density(aes(x = value, color = name), size = 1.05) +
  scale_x_log10(
    name = "Price",
    limits = c(5000, 1900000),
    labels = scales::dollar
  ) +
  labs(x = "Price", y = "Density") +
  guides(color = guide_legend(title = "Value Source")) +
  theme_minimal()
```

<br>

## Overall Ratio Distributions

```{r ratio_dist, warning=FALSE, message=FALSE}
# Plot histogram of ratios by modeling class (single-family vs multi-family)
# Ratios here are calculated using the MOST RECENT SALE for each property
pv_final_values %>%
  pivot_longer(c(lgbm_value, final_value)) %>%
  mutate(
    ratio = value / meta_sale_price,
    name = fct_recode(
      factor(name, levels = c("lgbm_value", "final_value")),
      "Initial Model Value" = "lgbm_value",
      "Final Model Value" = "final_value"
    )
  ) %>%
ggplot() +
  geom_histogram(aes(x = ratio, fill = name), binwidth = 0.05) +
  scale_x_continuous(breaks = breaks_extended(10), limits = c(0, 4)) +
  scale_fill_hue(name = "Ratio Type") +
  labs(
    x = "Sale Ratio",
    y = "Number of Properties"
  ) +
  facet_grid(vars(name), vars(meta_modeling_group)) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    strip.text = element_text(size = 12),
    axis.title.x = element_text(margin = margin(t = 6), size = 10),
    axis.title.y = element_text(margin = margin(r = 10), size = 10),
    panel.grid.minor = element_blank()
  ) +
  theme(
    strip.text = element_text(size = 12)
  )

```

<br>

## Ratio Distribution by Township by Sale Price Decile

```{r ratio_decile, warning=FALSE, message=FALSE, results='hide'}
# Split final values into decile by sale price, get count and distribution for
# each decile
decile_data_ratio <- pv_final_values %>%
  filter(
    !is.na(meta_sale_price), !is.na(final_value),
    !is.na(lgbm_value)
  ) %>%
  mutate(
    decile = ntile(meta_sale_price, 10),
    across(c(lgbm_value, final_value), ~ .x / meta_sale_price)
  ) %>%
  group_by(decile) %>%
  mutate(decile_label = paste(
    dollar(min(meta_sale_price), 1, scale = 1/1000, suffix = "K"),
    dollar(max(meta_sale_price), 1, scale = 1/1000, suffix = "K"),
    sep = " - ")
  ) %>%
  ungroup() %>%
  mutate(decile_label = fct_rev(fct_reorder(factor(decile_label), decile))) %>%
  pivot_longer(c(lgbm_value, final_value), names_to = "name", values_to = "ratio") %>%
  mutate(
    name = fct_recode(
      factor(name, levels = c("final_value", "lgbm_value")),
      "Model Value" = "lgbm_value",
      "Final Value" = "final_value"
    )
  )


# Function to create decile plot based on a grouping variable. Goal is to show
# the shift in ratio distribution caused by post-modeling adjustment
decile_plot_ratio <- function(data, col_var) {
  
  data %>%
    group_by({{col_var}}, decile_label) %>%
    mutate(count = n()) %>%
  ggplot() +
    geom_boxplot(aes(x = ratio, color = name), outlier.alpha = 0.05) +
    geom_text(
      aes(x = 3, y = 0, label = count),
      size = 3,
      hjust = 1,
      check_overlap = TRUE
    ) +
    scale_color_hue(name = "Ratio Type", direction = -1) +
    facet_grid(
      rows = vars(decile_label),
      cols = vars({{col_var}}),
      switch = "y"
    ) +
    xlim(0, 3) +
    labs(x = "Sale Ratio", y = "") +
    guides(color = guide_legend(reverse = TRUE)) +
    theme_minimal() +
    theme(
      legend.position = "none",
      axis.title.x = element_text(margin = margin(t = 10), size = 10),
      axis.text.y = element_blank(),
      panel.grid.major.y = element_blank(),
      panel.grid.minor.y = element_blank(),
      strip.text = element_text(size = 12),
      strip.text.y.left = element_text(angle = 0, hjust = 1),
      strip.text.x = element_text(margin = margin(b = 10)),
      panel.grid.minor = element_blank()
    )
}


# Split into a separate decile plot for every 4 townships, otherwise all
# townships would be in a single plot
chunk <- function(x, n) split(x, sort(rank(x) %% n))
towns <- sort(unique(decile_data_ratio$town_name))
towns <- chunk(towns, ceiling(length(towns) / 4))

lapply(towns, function(chunk) decile_plot_ratio(
  decile_data_ratio %>% filter(town_name %in% chunk),
  town_name
))

```

<br>

## Spatial Distribution of Largest YoY Changes (Certified to Final Model Value)

```{r outlier_map, message=FALSE}
# Create a township level map showing the location of the largest YoY percentage
# changes. Goal is to look for patterns of changes
pv_final_values %>%
  filter(!is.infinite(certified_yoy_pct_change)) %>%
  mutate(
    dir = ifelse(certified_yoy_pct_change > 0, "Increase", "Decrease"),
    outlier = is_outlier(
      certified_yoy_pct_change,
      method = "quantile",
      probs = c(0.005, 0.995),
      na.rm = TRUE
    )
  ) %>%
  filter(outlier) %>%
  mutate(decile_label = cut(
    x = certified_yoy_pct_change,
    breaks = c(-Inf, -1, -0.5, 0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, Inf),
    labels = c(
      "< -100%", "-100% to -50%", "-50% to 0%", "0% to 50%", "50% to 100%",
      "100% to 150%", "150% to 200%", "200% to 250%", "250% to 300%",
      "300% to 350%", "350% to 400%", "> 400%"
    )
  )) %>%
  ungroup() %>%
  st_as_sf(coords = c("geo_longitude", "geo_latitude"), crs = 4326) %>%
ggplot() +
  geom_sf(data = town_shp %>% filter(township_name %in% pv_final_values$town_name)) +
  geom_sf(
    aes(geometry = geometry, color = fct_rev(decile_label)),
    size = 0.7,
    alpha = 0.7
  ) +
  guides(color = guide_legend(title = "YoY % Change")) +
  facet_wrap(vars(dir)) +
  theme_void() +
  theme(
    strip.text = element_text(size = 12)
  )

```
