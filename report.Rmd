---
title: "Model Summary"
author: "Cook County Assessor's Office"
date: "`r format(Sys.time(), '%d %B, %Y @ %r')`"
output: html_document
params:
  filter: "TRUE"
  triad: "City"
---

```{r setup, include=FALSE}
library(arrow)
library(dplyr)
library(tidyr)
library(DT)
library(sf)
library(ggplot2)
library(stringr)
library(forcats)
library(scales)
library(tune)
library(ccao)
library(assessr)
source("R/cknn_funs.R")

knitr::opts_chunk$set(echo = FALSE, out.width = '100%')

# Filter to specific triad. Set with system variable else param defined in yaml
report_filter <- Sys.getenv("R_REPORT_FILTER", unset = NA)
report_filter <- as.logical(ifelse(
  !is.na(report_filter),
  report_filter,
  params$filter
))

# Triad to use for report. Set with system variable else param defined in yaml
report_triad <- Sys.getenv("R_REPORT_TRIAD", unset = NA)
report_triad <- ifelse(!is.na(report_triad), report_triad, params$triad)
```

```{r summary, message=FALSE}
# Load test set results
test_res <- read_parquet("data/testdata.parquet") %>%
  mutate(
    town_name = town_convert(meta_town_code),
    triad = factor(
      town_get_triad(meta_town_code, name = TRUE),
      levels = c("North", "City", "South")
    )
  )

# Filter to specific triad based on report param
if (report_filter) {
test_res <- test_res %>%
  filter(triad == report_triad)
}

# Summarize test set results by township
test_summary <- test_res %>%
  group_by(town_name) %>%
  summarize(
    count = n(),
    across(enet:stack, ~ cod(.x / meta_sale_price), .names = "{.col}_cod"),
    num_trimmed = sum(is_outlier(stack / meta_sale_price, method = "quantile")),
    stack_cod_trim = ccao_cod(stack / meta_sale_price)$COD
  ) %>%
  arrange(stack_cod_trim) %>%
  rename_with(~ gsub("_cod", "", .x), c(ends_with("_cod"), ends_with("_trim")))

# Create an interactive table of the test set results by township
test_summary %>%
  datatable(
    rownames = FALSE,
    filter = "none",
    autoHideNavigation = TRUE,
    selection = "none",
    options = list(
      autoWidth = TRUE,
      paging = FALSE,
      searching = FALSE,
      info = FALSE
    )
  ) %>%
  formatRound(2, digits = 0) %>%
  formatRound(c(3:7, 9))
```

<br>

## Map of COD by Township by Model Type

```{r map}
# Vector of model name order (in the order run in model.R)
model_order <- c("enet", "xgb", "rf", "cknn", "stack", "stack_trim")

# Generate township level map of COD
test_summary %>%
  pivot_longer(c(enet:stack, stack_trim)) %>%
  left_join(ccao::town_shp, by = c("town_name" = "township_name")) %>%
  st_set_geometry("geometry") %>%
  mutate(name = factor(name, levels = model_order)) %>%
ggplot() +
  geom_sf(aes(fill = value, geometry = geometry)) +
  scale_fill_distiller(name = "COD", palette = "Spectral") +
  facet_wrap(vars(name)) +
  theme_void() +
  theme(
    strip.text = element_text(size = 12)
  )
```

<br>

## Ratio Distribution by Township by Sale Price Decile

```{r ratio_decile, warning=FALSE, message=FALSE, results='hide'}
# Split test data into sale price decile, then calculate distribution of 
# ratios for each decile
decile_data <- test_res %>%
  mutate(
    decile = ntile(meta_sale_price, 10),
    across(enet:stack, ~ .x / meta_sale_price)
  ) %>%
  group_by(decile) %>%
  mutate(decile_label = paste(
    dollar(min(meta_sale_price), 1, scale = 1/1000, suffix = "K"),
    dollar(max(meta_sale_price), 1, scale = 1/1000, suffix = "K"),
    sep = " - ")
  ) %>%
  ungroup() %>%
  mutate(decile_label = fct_rev(fct_reorder(factor(decile_label), decile))) %>%
  pivot_longer(enet:stack, names_to = "model", values_to = "ratio") %>%
  mutate(model = factor(model, levels = model_order))

# Function to create decile plot based on a grouping variable
decile_plot <- function(data, col_var) {
  
  data %>%
    group_by({{col_var}}, decile_label) %>%
    mutate(count = n()) %>%
  ggplot() +
    geom_boxplot(aes(x = ratio), outlier.alpha = 0.05) +
    geom_text(
      aes(x = 3, y = 0.25, label = count),
      size = 3,
      hjust = 1,
      check_overlap = TRUE
    ) +
    scale_y_continuous(position = "right") +
    facet_grid(
      rows = vars(decile_label),
      cols = vars({{col_var}}),
      switch = "y"
    ) +
    xlim(0, 3) +
    labs(x = "Sale Ratio", y = "") +
    theme_minimal() +
    theme(
      axis.title.x = element_text(margin = margin(t = 10), size = 10),
      axis.text.y = element_blank(),
      strip.text = element_text(size = 12),
      strip.text.y.left = element_text(angle = 0, hjust = 1),
      strip.text.x = element_text(margin = margin(b = 10)),
      panel.grid.minor = element_blank()
    )
}

# Split into a separate decile plot for every 4 townships
chunk <- function(x, n) split(x, sort(rank(x) %% n))
towns <- sort(unique(decile_data$town_name))
towns <- chunk(towns, ceiling(length(towns) / 4))

lapply(towns, function(chunk) decile_plot(
  decile_data %>% filter(town_name %in% chunk),
  town_name
))

```

<br>

## Ratio Distribution by Model Type by Sale Price Decile

```{r ratio_model, warning=FALSE}
decile_plot(decile_data, model)
```

<br>

# Outlier Analysis

---

## Overall Ratio Distribution (Stack Model Pred. / Sale Price)

```{r outlier_dist, warning=FALSE, message=FALSE}
# Get the overall distribution for stack model trimmed and untrimmed
outlier_dist <- test_res %>%
  group_by(town_name) %>%
  mutate(
    outlier = is_outlier(stack / meta_sale_price, method = "quantile"),
    trimmed = "Trimmed"
  ) %>%
  filter(!outlier) %>%
  bind_rows(test_res %>% mutate(trimmed = "Not Trimmed")) %>%
  mutate(ratio = stack / meta_sale_price) 

# Find 1st and 99th percentile for trimmed and untrimmed ratios
quantiles <- outlier_dist %>%
  group_by(trimmed) %>%
  summarize(q01 = quantile(ratio, 0.01), q99 = quantile(ratio, 0.99))

# Plot histogram of ratios
ggplot(outlier_dist) +
  geom_histogram(aes(x = ratio), binwidth = 0.05) +
  geom_rect(
    data = quantiles,
    aes(xmin = -Inf, xmax = q01, ymin = -Inf, ymax = Inf, fill = trimmed),
    alpha = 0.3
  ) +
  geom_rect(
    data = quantiles,
    aes(xmin = q99, xmax = Inf, ymin = -Inf, ymax = Inf, fill = trimmed),
    alpha = 0.3
  ) +
  scale_x_continuous(breaks = breaks_extended(10), limits = c(0, 4)) +
  guides(fill = FALSE) +
  labs(
    x = "Sale Ratio",
    y = "Number of Properties",
    caption = "*Colored regions represent < 1st and > 99th percentile"
  ) +
  facet_wrap(vars(trimmed), ncol = 1) +
  theme_minimal() +
  theme(
    strip.text = element_text(size = 12),
    axis.title.x = element_text(margin = margin(t = 6), size = 10),
    axis.title.y = element_text(margin = margin(r = 10), size = 10),
    panel.grid.minor = element_blank()
  ) +
  theme(
    strip.text = element_text(size = 12)
  )

```

<br>

## Spatial Distribution of Outliers

```{r outlier_map, message=FALSE}

outlier_dist %>%
  left_join(quantiles, by = "trimmed") %>%
  filter(ratio < q01 | ratio > q99) %>%
  ungroup() %>%
  st_as_sf(coords = c("geo_longitude", "geo_latitude"), crs = 3435) %>%
  st_transform(4326) %>%
ggplot() +
  geom_sf(data = town_shp %>% filter(township_name %in% test_res$town_name)) +
  geom_sf(aes(geometry = geometry, color = trimmed)) +
  facet_wrap(vars(trimmed), nrow = 1) +
  guides(color = FALSE) +
  theme_void() +
  theme(
    strip.text = element_text(size = 12)
  )

```

<br>

## Outlier Table

Table shows only observations less than the 0.1 percentile and greater than the 99.9 percentile.

```{r outlier_table}
# Create a table of outliers from the 0.01 and 99.9 percentiles
outlier_dist %>%
  group_by(trimmed) %>%
  mutate(q01 = quantile(ratio, 0.001), q99 = quantile(ratio, 0.999)) %>%
  ungroup() %>%
  filter(ratio < q01 | ratio > q99) %>%
  mutate(
    meta_pin = pin_format_pretty(meta_pin),
    econ_tax_rate = econ_tax_rate / 100,
    Address = paste(geo_property_address, geo_property_zip, sep = ", ")
  ) %>%
  select(
    Trimmed = trimmed, Township = town_name, PIN = meta_pin, Address,
    `Sale Price` = meta_sale_price, `Stacked Model` = stack,
    any_of(vars_dict %>% filter(var_is_predictor) %>% pull(var_name_standard)),
    -meta_town_code
  ) %>%
  vars_recode(type = "short", as_factor = FALSE) %>%
  vars_rename(names_from = "standard", names_to = "pretty") %>%
  datatable(
    rownames = FALSE,
    autoHideNavigation = TRUE,
    selection = "none",
    options = list(
      scrollX = TRUE,
      autoWidth = TRUE,
      searchHighlight = TRUE,
      paging = TRUE,
      columnDefs = list(list(targets = c(2, 3), width = "100px"))
    )
  ) %>%
  formatStyle(
    "Trimmed",
    target = "row",
    backgroundColor = styleEqual(
      c("Trimmed", "Not Trimmed"),
      c("#ace2e3", "#f2b1ac")
    )
  ) %>%
  formatCurrency(
    c("Sale Price", "Stacked Model", "Median Income"),
    digits = 0
  ) %>%
  formatPercentage(
    c("Tax Rate"), digits = 2
  )
```

<br>

# Model Tuning

---

## Model Correlation (Spearman)

```{r corr}
# Prepare correlation data matrix
model_cor <- as_tibble(cor(select(test_res, enet:stack), method = "spearman")) %>%
  mutate(name2 = names(.)) %>%
  pivot_longer(-name2) %>%
  mutate(
    across(contains("name"), ~ factor(.x, levels = model_order)),
    name2 = fct_rev(name2),
    value = round(value, 3)
  )

# Plot model correlation
ggplot(model_cor) +
  geom_tile(aes(x = name, y = name2, fill = value)) +
  geom_text(aes(x = name, y = name2, label = value, color = value > 0.98)) +
  scale_x_discrete(expand = c(0, 0), position = "top") +
  scale_y_discrete(expand = c(0, 0)) +
  scale_fill_distiller(palette = "RdBu", name = "Correlation") +
  scale_color_manual(
    values = c("TRUE" = "white", "FALSE" = "black"),
    guide = FALSE
  ) +
  labs(x = "", y = "") +
  theme_minimal() +
  theme(
    legend.title = element_text(margin = margin(b = 6)),
    axis.text = element_text(size = 14)
  )
```

<br>

## Final Hyperparameters

```{r params}
# Load model results for each model and append to data frame
model_results <- tibble()

enet_params_path <- "data/models/enet_params.rds"
if (file.exists(enet_params_path)) {
  enet_params <- readRDS(enet_params_path)
  enet_final_params <- enet_params %>%
    mutate(Iterations = max(.iter)) %>%
    select_by_one_std_err(penalty, mixture, metric = "codm") %>%
    mutate(Model = "enet")
  
  model_results <- bind_rows(model_results, enet_final_params)
}

xgb_params_path <- "data/models/xgb_params.rds"
if (file.exists(xgb_params_path)) {
  xgb_params <- readRDS(xgb_params_path)
  xgb_final_params <- xgb_params %>%
    mutate(Iterations = max(.iter)) %>%
    select_by_one_std_err(
      mtry, min_n, tree_depth, loss_reduction,
      learn_rate, sample_size, metric = "codm"
    ) %>%
    mutate(Model = "xgb")

  model_results <- bind_rows(model_results, xgb_final_params)
}

rf_params_path <- "data/models/rf_params.rds"
if (file.exists(rf_params_path)) {
  rf_params <- readRDS(rf_params_path)
  rf_final_params <- rf_params %>%
    mutate(Iterations = max(.iter)) %>%
    select_by_one_std_err(mtry, min_n, metric = "codm") %>%
    mutate(Model = "rf")
  
  model_results <- bind_rows(model_results, rf_final_params)
}

cknn_params_path <- "data/models/cknn_params.rds"
if (file.exists(cknn_params_path)) {
  cknn_params <- readRDS(cknn_params_path)
  cknn_final_params <- cknn_params %>%
    filter(cod == min(cod, na.rm = TRUE)) %>%
    mutate(Model = "cknn")
  
  model_results <- bind_rows(model_results, cknn_final_params)
}

# Table of all final model parameters
model_results %>%
  select(-any_of(c(
    "n", "std_err", ".iter", ".config", ".metric", ".estimator",
    ".best", ".bound", "rmse", "rsq", "cod", "prd", "prb"
  ))) %>%
  rename(Performance = mean) %>%
  relocate(c(Model, Performance, Iterations), .before = NULL) %>%
  pivot_longer(
    cols = -(Model:Iterations),
    names_to = "Param Name",
    values_to = "Param Value",
    values_drop_na = TRUE
  ) %>%
  datatable(
    rownames = FALSE,
    filter = "none",
    autoHideNavigation = TRUE,
    selection = "none",
    options = list(
      autoWidth = TRUE,
      paging = FALSE,
      searching = FALSE,
      info = FALSE
    )
  ) %>%
  formatRound(c(2, 5), digits = 3)

```

<br>

## Hyperparameter Tuning

```{r param_plots, warning=FALSE}
# Create autoplot of model params for those that exist
if (exists("enet_params")) {
  autoplot(enet_params, metric = "codm", type = "marginals") +
    geom_smooth(method = "lm", formula = y ~ poly(x, 3), se = F) +
    labs(title = "ElasticNet Tuning Results") +
    theme_minimal()
}

if (exists("xgb_params")) {
  autoplot(xgb_params, metric = "codm", type = "marginals") +
    geom_smooth(method = "lm", formula = y ~ poly(x, 3), se = F) +
    labs(title = "XGBoost Tuning Results") +
    theme_minimal()
}

if (exists("rf_params")) {
  autoplot(rf_params, metric = "codm", type = "marginals") +
    geom_smooth(method = "lm", formula = y ~ poly(x, 3), se = F) +
    labs(title = "Random Forest Tuning Results") +
    theme_minimal()
}

if (exists("cknn_params")) {
  cknn_grid_plot(cknn_params, m, k, l, cod) +
    labs(title = "CkNN Tuning Results")
}
```

<br>

## CkNN Variable Weights

```{r cknn_weights}
cknn_var_weights_path <- "data/models/cknn_weights.rds"
if (file.exists(cknn_var_weights_path)) {
cknn_var_weights <- readRDS(cknn_var_weights_path)
names_pretty <- cknn_var_weights %>%
    pivot_wider() %>%
    vars_rename(names_from = "standard", names_to = "pretty",type = "vector")
    
cknn_var_weights %>%
  mutate("Variable Full Name" = names_pretty) %>%
  rename("Variable Name" = name, "Relative Weight" = value) %>%
  relocate(`Variable Full Name`, .before = NULL) %>%
  knitr::kable(digits = 3)
}
```

<br>

## Model Training Time

```{r timings, fig.height=2}
model_timings_path <- "data/models/model_timings.rds"
if (file.exists(model_timings_path)) {
  readRDS(model_timings_path) %>%
    filter(model != "full") %>%
    mutate(
      across(c(tic:toc, elapsed), ~ .x / 3600),
      model = factor(model, levels = c("elasticnet", "xgb", "rf", "cknn"))
    ) %>%
  ggplot() +
    geom_rect(aes(ymin = 0, ymax = 1, xmin = tic, xmax = toc, fill = model)) +
    scale_x_continuous(expand = c(0, 0), breaks = extended_breaks(18)) +
    scale_y_continuous(expand = c(0, 0)) +
    guides(fill = guide_legend(title = "Model")) +
    labs(x = "Number of Hours Elapsed While Training") +
    theme(
      axis.ticks.y = element_blank(),
      axis.text.y = element_blank(),
      axis.title.x = element_text(margin = margin(t = 6))
    )
}
```

